# P1.1 Rule Matching → PartitionSpec Utilities

## Objective
- Implement the first tranche of sharding helpers so tensor-parallel plans can translate rule patterns into concrete `PartitionSpec` trees without manual wiring.
- Lock down deterministic rule resolution and error reporting before downstream mesh integrations begin.
- Back the new utilities with targeted unit tests that exercise path enumeration, glob matching, precedence, and defaults.

## Current Context Snapshot
- `src/titanax/parallel/sharding.py` exists with stubs for `tree_paths`, `spec_for`, and `build_param_specs`; each currently raises `NotImplementedError`.
- Type aliases for rule maps (`RuleMap`, `PartitionRule`) are already defined, and consumers import `PartitionSpec` via `titanax.types`.
- `tests/unit/test_sharding_utils.py` is a placeholder module that imports the helpers but is skipped globally pending implementation.
- `notes/updated_plan.md` specifies the intended behavior: fnmatch-driven glob support, longest/most-specific precedence, and a default `PartitionSpec()` fallback.
- `titanax.exceptions` provides `sharding_error`, which should be reused for ambiguity/conflict messaging once logic lands.

## Deliverables
- Working implementations of `tree_paths`, `spec_for`, and `build_param_specs` in `src/titanax/parallel/sharding.py` aligned with documented semantics.
- Deterministic precedence handling for overlapping glob patterns, including explicit conflict errors when rules cannot be disambiguated.
- Refreshed `tests/unit/test_sharding_utils.py` covering path enumeration, rule matching, precedence, default handling, and whole-tree spec construction (leaving P1.2 helpers intentionally skipped).
- Lightweight test fixtures and helpers to construct representative pytree parameter structures for assertions.
- Updated notes/tests remain JAX-compatible and type-check-ready with existing `titanax.types` aliases.

## Work Breakdown & Technical Details

### 1. Implement `tree_paths`
- Use `jax.tree_util.tree_flatten_with_path` to capture leaf paths; convert each `KeyPathEntry` to a string segment using:
  - `DictKey(key)` → `str(key)`; expect canonical usage with string keys, but support ints.
  - `SequenceKey(index)` → `str(index)`.
  - `AttrKey`/`GetAttrKey` → attribute name.
- Join segments with `/` and collect in traversal order to ensure deterministic alignment with `tree_unflatten` later.
- Return a tuple of strings; document that dict insertion order drives deterministic results.

### 2. Implement `spec_for`
- Iterate over `rules` (any `Mapping[str, PartitionRule]`) evaluating `fnmatch.fnmatchcase(path, pattern)` for matches.
- Precompute precedence metrics for each pattern:
  - Segment count (`pattern.split('/')` length) – prioritize higher counts.
  - Wildcard count (number of `*`/`?` characters) – fewer wins.
  - Literal length (length minus wildcard count) – longer wins.
- Select the best match using the above as a lexicographic key; if multiple rules tie exactly, raise `sharding_error(path, "multiple patterns matched with equal precedence", suggestion=...)` referencing offending patterns.
- Instantiate and return `PartitionSpec(*rule)` for the winning rule; if no match and `default` is `None`, default to a replicated `PartitionSpec()`.

### 3. Implement `build_param_specs`
- Flatten `params_tree` with `tree_flatten_with_path` to get `(path_entries, leaves)`; reuse `tree_paths` to generate matching string identifiers.
- For each leaf path, call `spec_for(path, rules, default=default)` and collect resulting specs in leaf order.
- Use `jax.tree_util.tree_unflatten` with the original `treedef` and the computed spec list to rebuild the spec tree.
- Wrap `PartitionSpec` construction errors via `sharding_error` where appropriate to surface context.

### 4. Update `tests/unit/test_sharding_utils.py`
- Remove the module-level skip; instead apply `@pytest.mark.skip(reason="P1.2 pending")` to P1.2-specific placeholder tests (`apply_named_sharding`, `shard_batch_specs`).
- Add fixtures for representative param structures (nested dicts, tuple leaves) and example rules (including outputs from `tp_helpers.mlp_rules` plus custom wildcard cases).
- Test coverage should include:
  - `tree_paths` produces expected paths for mixed structures.
  - `spec_for` exact match, wildcard match, longest-path precedence, wildcard tie-break, default fallback, and conflict error (`pytest.raises` expecting `ShardingError`).
  - `build_param_specs` preserves pytree structure and aligns produced specs with rule expectations and defaults.
- Use `PartitionSpec` objects in assertions to mirror production usage.

### 5. Validation & Tooling
- Run `uv run python -m pytest tests/unit/test_sharding_utils.py` to confirm new tests pass once implemented.
- Spot-check `mypy` and format via `black`/`ruff` as part of pre-commit instructions.

## Acceptance Criteria
- `tree_paths`, `spec_for`, and `build_param_specs` no longer raise `NotImplementedError` and behave per updated plan semantics.
- Rule precedence is deterministic, with ambiguous tie cases emitting `ShardingError` that names the parameter path.
- Unit tests meaningfully exercise P1.1 scope, pass locally, and leave P1.2 placeholders clearly marked as skipped.
- No regressions introduced in existing modules/tests; code satisfies Titanax style and typing guidelines.

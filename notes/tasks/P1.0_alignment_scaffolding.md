# P1.0 Alignment & Scaffolding

## Objective
- Align the tensor-parallel scaffolding with the current code layout and prepare a dedicated sharding utilities module so later P1 tasks only fill in implementations.
- Ensure engineering artifacts (modules, exports, tests, docs) consistently reference `tp_helpers` and the upcoming `sharding` utilities.

## Current Context Snapshot
- The legacy tensor-parallel rules module was removed; helper generators live in `src/titanax/parallel/tp_helpers.py`.
- There is no `src/titanax/parallel/sharding.py` yet; rule application logic is scattered (mostly unimplemented).
- No unit tests cover sharding utilities; `tests/unit/` only checks plan/tp_helpers/pp today.
- Public exports in `src/titanax/parallel/__init__.py` are minimal and do not surface sharding helpers.

## Deliverables for P1.0
- Repository has zero references (code, docs, notes) to the defunct module; everything points to `parallel/tp_helpers.py`.
- Skeleton `src/titanax/parallel/sharding.py` file with TODO stubs and shared types ready for P1.1–P1.2 implementation.
- Corresponding test scaffold `tests/unit/test_sharding_utils.py` containing imports + placeholder test classes/functions skipped for now.
- Updated package exports (`parallel/__init__.py`) and docs/notes to acknowledge the new module.

## Work Breakdown & Technical Details

- ### 1. Reference Realignment (legacy rules module → `parallel/tp_helpers.py`)
- Sweep repo (code + `notes/`) for references to the old module name; expect hits in `notes/plan.md` and any lingering TODOs.
- Update documentation snippets or TODO checklists to cite `tp_helpers` directly (ensure consistent casing in Markdown links/code fences).
- Confirm `tp_helpers` is imported wherever former `rules` import paths existed; adapt to actual symbol names (`mlp_rules`, `attention_rules`, etc.).
- Add `__all__` entries in `parallel/__init__.py` if we want wildcard imports to expose the helper API.

### 2. Sharding Module Scaffolding (`parallel/sharding.py`)
- Create module with descriptive module docstring outlining responsibilities (rule matching, `PartitionSpec` tree construction, `NamedSharding` helpers).
- Define shared type aliases up front to avoid circular imports, e.g.:
  - `RulePattern = str`
  - `PartitionRule = Tuple[AxisName | None, ...]`
  - `RuleMap = Dict[RulePattern, PartitionRule]`
  - `SpecTree = PyTree[PartitionSpec]`
- Add imports from `titanax.compat` for `PartitionSpec`, `NamedSharding`, and `pjit`-friendly types.
- Stub core functions with precise signatures and `NotImplementedError` placeholders so downstream tasks can fill them in:
  - `tree_paths(tree: PyTree) -> Tuple[str, ...]`
  - `spec_for(path: str, rules: Mapping[str, PartitionRule], *, default: PartitionSpec | None = None) -> PartitionSpec`
  - `build_param_specs(params_tree: PyTree, rules: Mapping[str, PartitionRule], *, default: PartitionSpec | None = None) -> SpecTree`
  - `apply_named_sharding(tree: PyTree, mesh: Mesh, spec_tree: SpecTree) -> PyTree`
  - `shard_batch_specs(batch_example: PyTree, dp_axis: AxisName) -> SpecTree`
- Document expectations for pattern precedence (longest match wins) and integration touchpoints with `Plan` and Engine.
- Ensure stubs include lightweight validation placeholders (e.g., TODO comments for conflict detection) to guide P1.1/P1.2.

### 3. Test Skeleton (`tests/unit/test_sharding_utils.py`)
- Create file with high-level test structure: separate test classes/sections for pattern matching, spec building, and named sharding application.
- Use `pytest.importorskip("jax")` if full JAX is required, but keep actual tests marked with `pytest.mark.skip(reason="P1.1 pending")` to avoid failures.
- Include fixture stubs for simple parameter trees (e.g., nested dict of arrays) to demonstrate expected inputs once implementations land.
- Import the new module to ensure the test suite fails if the module disappears (basic smoke coverage).

### 4. Package & Documentation Touchpoints
- Update `src/titanax/parallel/__init__.py` to export the sharding utilities (even if only stubs) so downstream code can import from `titanax.parallel` consistently.
- Add short note in `notes/updated_plan.md` or associated sections referencing `parallel/sharding.py` instead of the legacy path.
- Verify `notes/plan.md` (older document) no longer instructs developers to work on the removed module.
- If README or spec references exist, adjust them in the same sweep (search for "rules.py").

## Acceptance Criteria
- All references to the defunct module path are removed or updated with clear replacement guidance.
- `parallel/sharding.py` and `tests/unit/test_sharding_utils.py` exist with descriptive scaffolding, no logic yet, and pass linting (imports resolve, no syntax errors).
- Running the existing test suite continues to succeed (new tests are skipped/pending, not failing).
- Documentation accurately reflects the new module layout and upcoming work focus.

## Open Questions / Follow-ups
- Confirm whether `Plan.tensor_parallel.rules` shape or typing assumptions require updates once `RuleMap` aliases exist.
- Decide if sharding utilities should live under `titanax.parallel` or a subpackage (e.g., `parallel.sharding` vs `parallel.sharding.utils`). Current plan assumes a flat module.
- Coordinate with Engine team on whether `apply_named_sharding` should return device arrays immediately or delay to compilation step (impacting lazy compile in P1.3).
